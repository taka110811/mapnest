# éšå±¤çš„åœ°å›³æ¤œç´¢UIå®Ÿè£…ã‚¬ã‚¤ãƒ‰ã€2024å¹´ç‰ˆã€‘

## ğŸ“ æ¦‚è¦

éƒ½é“åºœçœŒ â†’ å¸‚åŒºç”ºæ‘ â†’ ç”ºãƒ»å­— â†’ ã‚¹ãƒãƒƒãƒˆã¨ã„ã†éšå±¤æ§‹é€ ã§ã€åœ°å›³ä¸Šã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ã—ãªãŒã‚‰è¦³å…‰ã‚¹ãƒãƒƒãƒˆã‚’æ¢ç´¢ã§ãã‚‹é«˜æ€§èƒ½ãªã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–åœ°å›³UIã®å®Ÿè£…æ‰‹é †ã§ã™ã€‚Comfyã®æœ€æ–°ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ï¼ˆ2024å¹´ç‰ˆï¼‰ã‚’å‚è€ƒã«ã€ãƒ¢ãƒ€ãƒ³ãªæŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ã§æ§‹ç¯‰ã—ã¾ã™ã€‚

## ğŸ¯ å®Œæˆã‚¤ãƒ¡ãƒ¼ã‚¸

1. **åˆæœŸè¡¨ç¤º**: æ—¥æœ¬åœ°å›³å…¨ä½“ãŒè¡¨ç¤ºã•ã‚Œã€éƒ½é“åºœçœŒã”ã¨ã«è‰²åˆ†ã‘
2. **éƒ½é“åºœçœŒã‚¯ãƒªãƒƒã‚¯**: é¸æŠã—ãŸéƒ½é“åºœçœŒã«ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ã€å¸‚åŒºç”ºæ‘ãŒè‰²åˆ†ã‘è¡¨ç¤º
3. **å¸‚åŒºç”ºæ‘ã‚¯ãƒªãƒƒã‚¯**: é¸æŠã—ãŸå¸‚åŒºç”ºæ‘ã«ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ã€ç”ºãƒ»å­—ãŒè‰²åˆ†ã‘è¡¨ç¤º
4. **ç”ºãƒ»å­—ã‚¯ãƒªãƒƒã‚¯**: æœ€å¤§ã‚ºãƒ¼ãƒ ã€è¦³å…‰ã‚¹ãƒãƒƒãƒˆã®ãƒ”ãƒ³ãŒè¡¨ç¤º

## ğŸ› ï¸ æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯ã€2024å¹´æœ€æ–°ç‰ˆã€‘

### ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
- **ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**: Next.js 14 (App Router) + React + TypeScript
- **åœ°å›³ãƒ©ã‚¤ãƒ–ãƒ©ãƒª**: MapLibre GL JSï¼ˆLeafletã‹ã‚‰ç§»è¡Œï¼‰
- **ãƒ™ã‚¯ãƒˆãƒ«ã‚¿ã‚¤ãƒ«**: PMTilesï¼ˆé™çš„é…ä¿¡ï¼‰
- **ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚°**: Tailwind CSS
- **ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°**: Vercel

### ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰
- **è¨€èª**: Rust
- **ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯**: Actix Web
- **ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹**: ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªãƒ‡ãƒ¼ã‚¿æ§‹é€  + SQLiteï¼ˆæœ€å°é™ï¼‰
- **ãƒ›ã‚¹ãƒ†ã‚£ãƒ³ã‚°**: Google Cloud Run

### ã‚¤ãƒ³ãƒ•ãƒ©ãƒ»ãƒ‡ãƒ¼ã‚¿
- **CDN**: Cloudflare
- **ãƒ™ã‚¯ãƒˆãƒ«ã‚¿ã‚¤ãƒ«é…ä¿¡**: PMTilesï¼ˆé™çš„ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰
- **ç›£è¦–**: Google Cloud Logging

## ğŸš€ ä¸»è¦ãªæœ€é©åŒ–ãƒã‚¤ãƒ³ãƒˆ

1. **MapLibre GL JSã«ã‚ˆã‚‹é«˜æ€§èƒ½ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°**
2. **PMTilesã«ã‚ˆã‚‹é™çš„ãƒ™ã‚¯ãƒˆãƒ«ã‚¿ã‚¤ãƒ«é…ä¿¡**
3. **Rustãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã«ã‚ˆã‚‹è¶…é«˜é€Ÿãƒ¬ã‚¹ãƒãƒ³ã‚¹**
4. **Cloud Runã«ã‚ˆã‚‹ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹æ§‹æˆ**
5. **Vercelã«ã‚ˆã‚‹æœ€é©åŒ–ã•ã‚ŒãŸSSR/SSG**

## ğŸ“‹ å®Ÿè£…æ‰‹é †

### Phase 1: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

#### 1.1 Next.jsãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆ

```bash
# ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆä½œæˆï¼ˆæœ€æ–°ã®Next.jsï¼‰
npx create-next-app@latest mapnest --typescript --tailwind --app --src-dir

cd mapnest

# å¿…è¦ãªãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
npm install maplibre-gl react-map-gl
npm install pmtiles
npm install @turf/turf
npm install swr

# é–‹ç™ºç”¨ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸
npm install -D @types/mapbox-gl
```

#### 1.2 ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ 

```
mapnest/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ layout.tsx
â”‚   â”‚   â”œâ”€â”€ page.tsx
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â”œâ”€â”€ spots/route.ts
â”‚   â”‚   â”‚   â””â”€â”€ search/route.ts
â”‚   â”‚   â””â”€â”€ location/
â”‚   â”‚       â””â”€â”€ [slug]/page.tsx   # SSRãƒšãƒ¼ã‚¸
â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”œâ”€â”€ Map/
â”‚   â”‚   â”‚   â”œâ”€â”€ MapContainer.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ MapControls.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ VectorTileLayer.tsx
â”‚   â”‚   â”‚   â””â”€â”€ SpotMarkers.tsx
â”‚   â”‚   â”œâ”€â”€ UI/
â”‚   â”‚   â”‚   â”œâ”€â”€ SearchBar.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ FilterPanel.tsx
â”‚   â”‚   â”‚   â”œâ”€â”€ SpotCard.tsx
â”‚   â”‚   â”‚   â””â”€â”€ NavigationBreadcrumb.tsx
â”‚   â”‚   â””â”€â”€ Charts/
â”‚   â”‚       â””â”€â”€ HistogramFilter.tsx
â”‚   â”œâ”€â”€ hooks/
â”‚   â”‚   â”œâ”€â”€ useMapData.ts
â”‚   â”‚   â”œâ”€â”€ useVectorTiles.ts
â”‚   â”‚   â””â”€â”€ useSpotSearch.ts
â”‚   â”œâ”€â”€ lib/
â”‚   â”‚   â”œâ”€â”€ mapUtils.ts
â”‚   â”‚   â”œâ”€â”€ pmtiles.ts
â”‚   â”‚   â””â”€â”€ api.ts
â”‚   â””â”€â”€ types/
â”‚       â””â”€â”€ index.ts
â”œâ”€â”€ public/
â”‚   â””â”€â”€ tiles/           # PMTilesãƒ•ã‚¡ã‚¤ãƒ«
â”‚       â”œâ”€â”€ japan-prefectures.pmtiles
â”‚       â”œâ”€â”€ japan-cities.pmtiles
â”‚       â””â”€â”€ japan-districts.pmtiles
â”œâ”€â”€ rust-backend/        # Rustãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.rs
â”‚   â”‚   â”œâ”€â”€ handlers/
â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â””â”€â”€ utils/
â”‚   â””â”€â”€ Cargo.toml
â””â”€â”€ docker/
    â””â”€â”€ Dockerfile
```

### Phase 2: MapLibre GL JSå®Ÿè£…

#### 2.1 MapLibreã®è¨­å®š (`src/app/globals.css`)

```css
@import 'maplibre-gl/dist/maplibre-gl.css';

/* ã‚«ã‚¹ã‚¿ãƒ ã‚¹ã‚¿ã‚¤ãƒ« */
.maplibregl-popup {
  font-family: 'Inter', system-ui, sans-serif;
}

.maplibregl-ctrl-group {
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
}
```

#### 2.2 å‹å®šç¾© (`src/types/index.ts`)

```typescript
export interface ViewState {
  longitude: number;
  latitude: number;
  zoom: number;
  pitch?: number;
  bearing?: number;
}

export interface TouristSpot {
  id: string;
  name: string;
  name_en?: string;
  category: string;
  coordinates: [number, number];
  description: string;
  images: string[];
  rating: number;
  review_count: number;
  price_range?: string;
  opening_hours?: string;
  prefecture_code: string;
  city_code: string;
  district_code?: string;
}

export interface SearchFilters {
  categories: string[];
  rating_min: number;
  price_range: string[];
  keywords: string;
  bounds?: [[number, number], [number, number]];
}

export interface AreaInfo {
  code: string;
  name: string;
  name_en: string;
  level: 'prefecture' | 'city' | 'district';
  spot_count: number;
  population?: number;
  area_km2?: number;
}
```

#### 2.3 ãƒ¡ã‚¤ãƒ³ãƒãƒƒãƒ—ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ (`src/components/Map/MapContainer.tsx`)

```typescript
'use client';

import { useState, useCallback, useRef, useEffect } from 'react';
import Map, { 
  NavigationControl, 
  ScaleControl,
  GeolocateControl,
  MapRef 
} from 'react-map-gl';
import maplibregl from 'maplibre-gl';
import { PMTiles } from 'pmtiles';
import { ViewState, SearchFilters } from '@/types';
import VectorTileLayer from './VectorTileLayer';
import SpotMarkers from './SpotMarkers';
import { useSpotSearch } from '@/hooks/useSpotSearch';

// PMTilesãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ç™»éŒ²
let pmtilesProtocol: any;

export default function MapContainer() {
  const mapRef = useRef<MapRef>(null);
  const [viewState, setViewState] = useState<ViewState>({
    longitude: 138.2529,
    latitude: 36.2048,
    zoom: 5,
    pitch: 0,
    bearing: 0
  });
  
  const [selectedArea, setSelectedArea] = useState<{
    level: string;
    code: string;
  } | null>(null);

  const [filters, setFilters] = useState<SearchFilters>({
    categories: [],
    rating_min: 0,
    price_range: [],
    keywords: ''
  });

  // ã‚«ã‚¹ã‚¿ãƒ ãƒ•ãƒƒã‚¯ã§ã‚¹ãƒãƒƒãƒˆãƒ‡ãƒ¼ã‚¿å–å¾—
  const { spots, isLoading } = useSpotSearch(selectedArea, filters);

  // PMTilesãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®åˆæœŸåŒ–
  useEffect(() => {
    if (!pmtilesProtocol) {
      pmtilesProtocol = {
        type: 'pmtiles',
        protocolInit: (params: any) => {
          const pmtiles = new PMTiles(params.url);
          return {
            tile: async (params: any) => {
              const response = await pmtiles.getZxy(
                params.z,
                params.x,
                params.y
              );
              return response?.data;
            }
          };
        }
      };
      maplibregl.addProtocol('pmtiles', pmtilesProtocol.protocolInit);
    }
  }, []);

  // åœ°å›³ã‚¯ãƒªãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
  const handleMapClick = useCallback((event: any) => {
    const map = mapRef.current?.getMap();
    if (!map) return;

    // ã‚¯ãƒªãƒƒã‚¯ã—ãŸåœ°ç‰©ã®å–å¾—
    const features = map.queryRenderedFeatures(event.point, {
      layers: ['prefectures-fill', 'cities-fill', 'districts-fill']
    });

    if (features && features.length > 0) {
      const feature = features[0];
      const { code, level, name } = feature.properties;
      
      // ã‚¨ãƒªã‚¢é¸æŠã¨ã‚ºãƒ¼ãƒ 
      setSelectedArea({ level, code });
      
      // å¢ƒç•Œã«ãƒ•ã‚£ãƒƒãƒˆã™ã‚‹ã‚ˆã†ã‚ºãƒ¼ãƒ 
      if (feature.geometry.type === 'Polygon' || 
          feature.geometry.type === 'MultiPolygon') {
        const bounds = getBounds(feature.geometry);
        map.fitBounds(bounds, {
          padding: 50,
          duration: 1000
        });
      }
    }
  }, []);

  // ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸãƒ¬ã‚¤ãƒ¤ãƒ¼è¡¨ç¤ºåˆ¶å¾¡
  const getVisibleLayers = () => {
    const zoom = viewState.zoom;
    if (zoom < 7) return ['prefectures'];
    if (zoom < 10) return ['cities'];
    if (zoom < 13) return ['districts'];
    return ['spots'];
  };

  return (
    <div className="relative w-full h-screen">
      <Map
        ref={mapRef}
        {...viewState}
        onMove={(evt) => setViewState(evt.viewState)}
        onClick={handleMapClick}
        mapLib={maplibregl}
        mapStyle={{
          version: 8,
          sources: {},
          layers: []
        }}
        style={{ width: '100%', height: '100%' }}
        maxZoom={18}
        minZoom={4}
      >
        {/* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« */}
        <NavigationControl position="top-right" />
        <ScaleControl position="bottom-right" />
        <GeolocateControl 
          position="top-right"
          trackUserLocation
        />

        {/* ãƒ™ã‚¯ãƒˆãƒ«ã‚¿ã‚¤ãƒ«ãƒ¬ã‚¤ãƒ¤ãƒ¼ */}
        <VectorTileLayer
          visibleLayers={getVisibleLayers()}
          selectedArea={selectedArea}
        />

        {/* ã‚¹ãƒãƒƒãƒˆãƒãƒ¼ã‚«ãƒ¼ */}
        {getVisibleLayers().includes('spots') && (
          <SpotMarkers 
            spots={spots}
            isLoading={isLoading}
          />
        )}
      </Map>

      {/* UI ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ */}
      <div className="absolute top-4 left-4 right-4 z-10 pointer-events-none">
        <div className="pointer-events-auto">
          <SearchBar onSearch={(keywords) => 
            setFilters(prev => ({ ...prev, keywords }))
          } />
        </div>
      </div>

      {/* ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ‘ãƒãƒ« */}
      <FilterPanel
        filters={filters}
        onFiltersChange={setFilters}
        spotCount={spots.length}
      />
    </div>
  );
}
```

#### 2.4 ãƒ™ã‚¯ãƒˆãƒ«ã‚¿ã‚¤ãƒ«ãƒ¬ã‚¤ãƒ¤ãƒ¼ (`src/components/Map/VectorTileLayer.tsx`)

```typescript
import { useEffect } from 'react';
import { useMap } from 'react-map-gl';

interface Props {
  visibleLayers: string[];
  selectedArea: { level: string; code: string } | null;
}

export default function VectorTileLayer({ visibleLayers, selectedArea }: Props) {
  const { current: map } = useMap();

  useEffect(() => {
    if (!map) return;

    // éƒ½é“åºœçœŒãƒ¬ã‚¤ãƒ¤ãƒ¼
    if (!map.getSource('prefectures')) {
      map.addSource('prefectures', {
        type: 'vector',
        url: 'pmtiles:///tiles/japan-prefectures.pmtiles'
      });

      // å¡—ã‚Šã¤ã¶ã—ãƒ¬ã‚¤ãƒ¤ãƒ¼
      map.addLayer({
        id: 'prefectures-fill',
        type: 'fill',
        source: 'prefectures',
        'source-layer': 'prefectures',
        paint: {
          'fill-color': [
            'interpolate',
            ['linear'],
            ['get', 'spot_count'],
            0, '#FEE5D9',
            50, '#FCAE91',
            100, '#FB6A4A',
            200, '#DE2D26',
            500, '#A50F15'
          ],
          'fill-opacity': [
            'case',
            ['==', ['get', 'code'], selectedArea?.code || ''],
            0.9,
            0.6
          ]
        }
      });

      // å¢ƒç•Œç·šãƒ¬ã‚¤ãƒ¤ãƒ¼
      map.addLayer({
        id: 'prefectures-line',
        type: 'line',
        source: 'prefectures',
        'source-layer': 'prefectures',
        paint: {
          'line-color': '#fff',
          'line-width': 2,
          'line-opacity': 0.8
        }
      });

      // ãƒ©ãƒ™ãƒ«ãƒ¬ã‚¤ãƒ¤ãƒ¼
      map.addLayer({
        id: 'prefectures-label',
        type: 'symbol',
        source: 'prefectures',
        'source-layer': 'prefectures',
        layout: {
          'text-field': ['get', 'name'],
          'text-font': ['Noto Sans CJK JP Regular'],
          'text-size': 12
        },
        paint: {
          'text-color': '#333',
          'text-halo-color': '#fff',
          'text-halo-width': 1
        }
      });
    }

    // ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡¨ç¤º/éè¡¨ç¤ºåˆ¶å¾¡
    const updateLayerVisibility = () => {
      ['prefectures', 'cities', 'districts'].forEach(layer => {
        const isVisible = visibleLayers.includes(layer);
        ['fill', 'line', 'label'].forEach(suffix => {
          const layerId = `${layer}-${suffix}`;
          if (map.getLayer(layerId)) {
            map.setLayoutProperty(
              layerId,
              'visibility',
              isVisible ? 'visible' : 'none'
            );
          }
        });
      });
    };

    updateLayerVisibility();

    // ãƒ›ãƒãƒ¼åŠ¹æœ
    map.on('mousemove', 'prefectures-fill', (e) => {
      if (e.features && e.features.length > 0) {
        map.getCanvas().style.cursor = 'pointer';
        
        // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—è¡¨ç¤º
        const feature = e.features[0];
        const { name, spot_count } = feature.properties;
        
        // ãƒ„ãƒ¼ãƒ«ãƒãƒƒãƒ—å®Ÿè£…
      }
    });

    map.on('mouseleave', 'prefectures-fill', () => {
      map.getCanvas().style.cursor = '';
    });

  }, [map, visibleLayers, selectedArea]);

  return null;
}
```

### Phase 3: Rustãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰å®Ÿè£…

#### 3.1 Cargo.toml

```toml
[package]
name = "mapnest-backend"
version = "0.1.0"
edition = "2021"

[dependencies]
actix-web = "4"
actix-cors = "0.6"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
tokio = { version = "1", features = ["full"] }
sqlx = { version = "0.7", features = ["runtime-tokio-rustls", "sqlite"] }
anyhow = "1"
env_logger = "0.11"
dotenv = "0.15"
geojson = "0.24"
geo = "0.27"
rstar = "0.11"  # ç©ºé–“ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
rayon = "1.7"   # ä¸¦åˆ—å‡¦ç†

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
```

#### 3.2 ãƒ¡ã‚¤ãƒ³ã‚µãƒ¼ãƒãƒ¼ (`rust-backend/src/main.rs`)

```rust
use actix_web::{web, App, HttpServer, middleware};
use actix_cors::Cors;
use std::sync::Arc;
use anyhow::Result;

mod handlers;
mod models;
mod utils;
mod spatial_index;

use crate::models::AppState;
use crate::spatial_index::SpatialIndex;

#[actix_web::main]
async fn main() -> Result<()> {
    env_logger::init();
    dotenv::dotenv().ok();

    // ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ¡ãƒ¢ãƒªã«èª­ã¿è¾¼ã¿
    let spots_data = utils::load_spots_data()?;
    let spatial_index = Arc::new(SpatialIndex::new(spots_data));
    
    let app_state = web::Data::new(AppState {
        spatial_index,
    });

    println!("Server starting on http://0.0.0.0:8080");

    HttpServer::new(move || {
        App::new()
            .app_data(app_state.clone())
            .wrap(
                Cors::default()
                    .allow_any_origin()
                    .allow_any_method()
                    .allow_any_header()
            )
            .wrap(middleware::Logger::default())
            .wrap(middleware::Compress::default())
            .service(
                web::scope("/api")
                    .route("/spots", web::get().to(handlers::get_spots))
                    .route("/search", web::post().to(handlers::search_spots))
                    .route("/areas/{level}/{code}", web::get().to(handlers::get_area_info))
                    .route("/histogram", web::get().to(handlers::get_histogram_data))
            )
    })
    .bind("0.0.0.0:8080")?
    .run()
    .await?;

    Ok(())
}
```

#### 3.3 ç©ºé–“ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹å®Ÿè£… (`rust-backend/src/spatial_index.rs`)

```rust
use geo::{Point, Rect};
use rstar::{RTree, AABB};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct TouristSpot {
    pub id: String,
    pub name: String,
    pub coordinates: [f64; 2],
    pub category: String,
    pub rating: f32,
    pub review_count: u32,
    pub prefecture_code: String,
    pub city_code: String,
}

impl rstar::RTreeObject for TouristSpot {
    type Envelope = AABB<[f64; 2]>;

    fn envelope(&self) -> Self::Envelope {
        AABB::from_point(self.coordinates)
    }
}

pub struct SpatialIndex {
    rtree: RTree<TouristSpot>,
    spots: Vec<TouristSpot>,
}

impl SpatialIndex {
    pub fn new(spots: Vec<TouristSpot>) -> Self {
        let rtree = RTree::bulk_load(spots.clone());
        Self { rtree, spots }
    }

    pub fn search_in_bounds(&self, bounds: [[f64; 2]; 2]) -> Vec<TouristSpot> {
        let envelope = AABB::from_corners(bounds[0], bounds[1]);
        self.rtree
            .locate_in_envelope(&envelope)
            .cloned()
            .collect()
    }

    pub fn search_nearest(&self, point: [f64; 2], k: usize) -> Vec<TouristSpot> {
        self.rtree
            .nearest_neighbor_iter(&point)
            .take(k)
            .cloned()
            .collect()
    }

    pub fn filter_spots(&self, filters: &SearchFilters) -> Vec<TouristSpot> {
        use rayon::prelude::*;
        
        self.spots
            .par_iter()
            .filter(|spot| {
                // é«˜é€Ÿãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°å‡¦ç†
                let matches_category = filters.categories.is_empty() 
                    || filters.categories.contains(&spot.category);
                let matches_rating = spot.rating >= filters.rating_min;
                let matches_keyword = filters.keywords.is_empty()
                    || spot.name.contains(&filters.keywords);
                
                matches_category && matches_rating && matches_keyword
            })
            .cloned()
            .collect()
    }
}
```

### Phase 4: PMTilesé™çš„é…ä¿¡è¨­å®š

#### 4.1 PMTilesã®ç”Ÿæˆ

```bash
# tippecanoeã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«
brew install tippecanoe  # macOS
# ã¾ãŸã¯
git clone https://github.com/felt/tippecanoe.git
cd tippecanoe
make -j
make install

# GeoJSONã‹ã‚‰PMTilesã¸ã®å¤‰æ›
tippecanoe -o prefectures.pmtiles \
  --no-feature-limit \
  --no-tile-size-limit \
  --minimum-zoom=4 \
  --maximum-zoom=8 \
  --layer=prefectures \
  prefectures.geojson

# å¸‚åŒºç”ºæ‘ãƒ‡ãƒ¼ã‚¿
tippecanoe -o cities.pmtiles \
  --no-feature-limit \
  --no-tile-size-limit \
  --minimum-zoom=7 \
  --maximum-zoom=11 \
  --layer=cities \
  cities.geojson
```

#### 4.2 Vercelã§ã®é™çš„é…ä¿¡è¨­å®š (`vercel.json`)

```json
{
  "functions": {
    "src/app/api/spots/route.ts": {
      "maxDuration": 10
    }
  },
  "headers": [
    {
      "source": "/tiles/(.*)",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=31536000, immutable"
        },
        {
          "key": "Access-Control-Allow-Origin",
          "value": "*"
        }
      ]
    }
  ],
  "rewrites": [
    {
      "source": "/tiles/:path*",
      "destination": "https://cdn.example.com/tiles/:path*"
    }
  ]
}
```

### Phase 5: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

#### 5.1 ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚§ãƒƒãƒãƒ³ã‚°æœ€é©åŒ– (`src/hooks/useSpotSearch.ts`)

```typescript
import useSWR from 'swr';
import { TouristSpot, SearchFilters } from '@/types';

const fetcher = async (url: string, filters: SearchFilters) => {
  const response = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(filters)
  });
  
  if (!response.ok) throw new Error('Failed to fetch');
  return response.json();
};

export function useSpotSearch(
  area: { level: string; code: string } | null,
  filters: SearchFilters
) {
  const { data, error, isLoading } = useSWR(
    area ? [`/api/search`, filters] : null,
    ([url, filters]) => fetcher(url, filters),
    {
      revalidateOnFocus: false,
      dedupingInterval: 5000,
      keepPreviousData: true, // å‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¿æŒ
    }
  );

  return {
    spots: data?.spots || [],
    total: data?.total || 0,
    isLoading,
    error
  };
}
```

#### 5.2 Web Workeræ´»ç”¨ (`src/workers/dataProcessor.worker.ts`)

```typescript
// é‡ã„å‡¦ç†ã‚’Web Workerã§å®Ÿè¡Œ
self.addEventListener('message', async (event) => {
  const { type, data } = event.data;

  switch (type) {
    case 'PROCESS_GEOJSON':
      const processed = await processGeoJSON(data);
      self.postMessage({ type: 'GEOJSON_PROCESSED', data: processed });
      break;
      
    case 'CALCULATE_CLUSTERS':
      const clusters = calculateClusters(data.spots, data.zoom);
      self.postMessage({ type: 'CLUSTERS_CALCULATED', data: clusters });
      break;
  }
});

function processGeoJSON(geojson: any) {
  // Turf.jsã‚’ä½¿ã£ãŸé‡ã„åœ°ç†æ¼”ç®—
  // ...
}

function calculateClusters(spots: any[], zoom: number) {
  // Superclusterã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã§ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°
  // ...
}
```

### Phase 6: Cloud Runãƒ‡ãƒ—ãƒ­ã‚¤

#### 6.1 Dockerfile

```dockerfile
# ãƒ“ãƒ«ãƒ‰ã‚¹ãƒ†ãƒ¼ã‚¸
FROM rust:1.75 as builder

WORKDIR /app
COPY Cargo.toml Cargo.lock ./
COPY src ./src

RUN cargo build --release

# å®Ÿè¡Œã‚¹ãƒ†ãƒ¼ã‚¸
FROM debian:bookworm-slim

RUN apt-get update && apt-get install -y \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

COPY --from=builder /app/target/release/mapnest-backend /usr/local/bin/

EXPOSE 8080

CMD ["mapnest-backend"]
```

#### 6.2 Cloud Runãƒ‡ãƒ—ãƒ­ã‚¤ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

```bash
#!/bin/bash

# ãƒ“ãƒ«ãƒ‰ã¨ãƒ—ãƒƒã‚·ãƒ¥
docker build -t gcr.io/PROJECT_ID/mapnest-backend .
docker push gcr.io/PROJECT_ID/mapnest-backend

# Cloud Runã¸ãƒ‡ãƒ—ãƒ­ã‚¤
gcloud run deploy mapnest-backend \
  --image gcr.io/PROJECT_ID/mapnest-backend \
  --platform managed \
  --region asia-northeast1 \
  --memory 2Gi \
  --cpu 2 \
  --timeout 60 \
  --concurrency 1000 \
  --max-instances 100 \
  --min-instances 1 \
  --allow-unauthenticated
```

## ğŸ¯ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›®æ¨™

- **åˆæœŸãƒ­ãƒ¼ãƒ‰**: < 2ç§’
- **åœ°å›³æ“ä½œ**: 60fpsç¶­æŒ
- **API ãƒ¬ã‚¹ãƒãƒ³ã‚¹**: < 100msï¼ˆP95ï¼‰
- **æ¤œç´¢å‡¦ç†**: < 50ms
- **ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡**: < 200MBï¼ˆãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ï¼‰

## ğŸ“Š ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°

```typescript
// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬
export function measurePerformance() {
  // Core Web Vitals
  if (typeof window !== 'undefined' && 'web-vital' in window) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(console.log);
      getFID(console.log);
      getFCP(console.log);
      getLCP(console.log);
      getTTFB(console.log);
    });
  }
}
```

## ğŸš€ å®Ÿè¡Œã¨ãƒ†ã‚¹ãƒˆ

### é–‹ç™ºç’°å¢ƒ

```bash
# ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
npm run dev

# Rustãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰
cd rust-backend
cargo watch -x run
```

### ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ãƒ“ãƒ«ãƒ‰

```bash
# ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰
npm run build
npm run start

# ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰
cargo build --release
./target/release/mapnest-backend
```

## ğŸ’¡ 2024å¹´ç‰ˆã®ä¸»ãªæ”¹å–„ç‚¹

1. **MapLibre GL JSæ¡ç”¨**
   - WebGLãƒ™ãƒ¼ã‚¹ã®é«˜é€Ÿãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
   - 3Dè¡¨ç¤ºå¯¾å¿œ
   - ã‚¹ãƒ ãƒ¼ã‚ºãªã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³

2. **PMTilesé™çš„é…ä¿¡**
   - ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®è² è·è»½æ¸›
   - CDNé…ä¿¡ã§é«˜é€ŸåŒ–
   - åœ°ç†ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã®ç°¡ç´ åŒ–

3. **Rustãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰**
   - 1.5å€ã®æ€§èƒ½å‘ä¸Š
   - ãƒ¡ãƒ¢ãƒªå®‰å…¨æ€§
   - ä¸¦åˆ—å‡¦ç†ã®æ´»ç”¨

4. **Cloud Runæ¡ç”¨**
   - ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹ã§ã‚³ã‚¹ãƒˆå‰Šæ¸›
   - è‡ªå‹•ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
   - ãƒ­ã‚°ç®¡ç†ã®ç°¡ç´ åŒ–

5. **Vercelç§»è¡Œ**
   - Next.js SSRã®å®Œå…¨ã‚µãƒãƒ¼ãƒˆ
   - ã‚¨ãƒƒã‚¸é–¢æ•°ã®æ´»ç”¨
   - è‡ªå‹•æœ€é©åŒ–

## ğŸ“š å‚è€ƒãƒªã‚½ãƒ¼ã‚¹

- [MapLibre GL JS Documentation](https://maplibre.org/maplibre-gl-js/docs/)
- [PMTiles Specification](https://github.com/protomaps/PMTiles)
- [Actix Web Guide](https://actix.rs/)
- [Vercel Documentation](https://vercel.com/docs)
- [Cloud Run Documentation](https://cloud.google.com/run/docs)

---

ã“ã®ã‚¬ã‚¤ãƒ‰ã¯ã€Comfy 2024å¹´ç‰ˆã®æœ€æ–°ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã‚’å‚è€ƒã«ã€ãƒ¢ãƒ€ãƒ³ã§é«˜æ€§èƒ½ãªåœ°å›³æ¤œç´¢UIã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®åŒ…æ‹¬çš„ãªæ‰‹é †ã§ã™ã€‚
